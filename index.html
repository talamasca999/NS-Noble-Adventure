<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Northstar's Noble Adventure</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #262626;
            color: #d4d4d4;
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
        }

        .game-wrapper {
            position: relative;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
            border-radius: 4px;
            overflow: hidden;
        }

        canvas {
            background-color: #2d3e26; /* Darker grassy background */
            display: block;
        }

        /* Updated UI Overlay Layout */
        .ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
            pointer-events: none;
            display: flex;
            justify-content: space-between; /* Pushes children to far left and right */
            align-items: flex-start;
        }

        .ui-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .controls-hint {
            position: absolute;
            bottom: 10px;
            left: 0;
            width: 100%;
            text-align: center;
            color: #ccc;
            text-shadow: 1px 1px 0 #000;
            font-size: 0.9rem;
            pointer-events: none;
        }

        .bar-container { margin-bottom: 2px; }
        
        .bar-label {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 2px;
            color: #fff;
            text-shadow: 1px 1px 0 #000;
        }

        /* Skinnier Health Bars */
        .hp-bar-bg {
            width: 200px;
            height: 10px; /* Reduced height */
            background-color: #444;
            border: 2px solid #000;
        }
        .hp-bar-fill {
            height: 100%;
            background-color: #dc2626;
            width: 100%;
            transition: width 0.2s;
        }
        .tal-bar-fill {
            height: 100%;
            background-color: #fbbf24; /* Gold */
            width: 100%;
            transition: width 0.2s;
        }

        /* Kill Count Style */
        .kill-count {
            font-size: 11px;
            color: #aaa;
            text-shadow: 1px 1px 0 #000;
            margin-top: 2px;
        }

        .message-box {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }

        .message-content { text-align: center; color: white; }
        .message-content h1 { font-size: 3rem; margin-bottom: 1rem; color: #fca5a5; }

        .btn {
            background: #d97706;
            border: 2px solid #fff;
            color: white;
            padding: 15px 30px;
            font-size: 1.2rem;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            text-transform: uppercase;
        }
        .btn:hover { background: #b45309; }
    </style>
</head>
<body>

    <div class="game-wrapper">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        
        <div class="ui-overlay">
            <!-- Left Group: Northstar & Wave -->
            <div class="ui-group">
                <div class="bar-container">
                    <div class="bar-label">Northstar</div>
                    <div class="hp-bar-bg"><div id="playerHpBar" class="hp-bar-fill"></div></div>
                    <div class="kill-count" id="playerKillCount">Orcs Slain: 0</div>
                </div>
                <div class="bar-container" style="margin-top: 10px;">
                    <div class="bar-label" id="waveLabel">WAVE 1</div>
                </div>
            </div>

            <!-- Right Group: Talamasca -->
            <div class="ui-group" style="align-items: flex-end;"> <!-- Align to right -->
                <div class="bar-container" style="text-align: right;">
                    <div class="bar-label">Talamasca</div>
                    <div class="hp-bar-bg"><div id="talamascaHpBar" class="tal-bar-fill"></div></div>
                    <div class="kill-count" id="talamascaKillCount">Orcs Slain: 0</div>
                </div>
            </div>
        </div>

        <div class="controls-hint">
            Move: <b>Arrows/WASD</b> | Attack: <b>Space/Click</b> | Block: <b>Alt</b>
        </div>

        <div id="messageBox" class="message-box">
            <div class="message-content">
                <h1 id="msgTitle">Northstar's Noble Adventure</h1>
                <p id="msgScore" style="font-size: 1.5rem; margin-bottom: 20px;">Press START to face the Orc Hordes.</p>
                <button id="restartBtn" class="btn">START GAME</button>
            </div>
        </div>
    </div>

    <script>
        // --- Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        const playerHpBar = document.getElementById('playerHpBar');
        const talamascaHpBar = document.getElementById('talamascaHpBar');
        const playerKillCountEl = document.getElementById('playerKillCount');
        const talamascaKillCountEl = document.getElementById('talamascaKillCount');
        const waveLabel = document.getElementById('waveLabel');
        const messageBox = document.getElementById('messageBox');
        const msgTitle = document.getElementById('msgTitle');
        const msgScore = document.getElementById('msgScore');
        const restartBtn = document.getElementById('restartBtn');

        // --- Game Constants ---
        const PLAYER_SPEED = 200;
        const PLAYER_SIZE = 25; 
        const SWORD_RANGE = 90;
        const SWORD_ARC = Math.PI / 1.5; 
        const ATTACK_DURATION = 0.2; 
        const ATTACK_COOLDOWN = 0.4;
        const PLAYER_HEAL_AMOUNT = 30;

        const TAL_SPEED = 300; 
        const TAL_SWORD_RANGE = 90;
        const TAL_ATTACK_DUR = 0.1;
        const TAL_ATTACK_CD = 0.2; 
        const TAL_DAMAGE = 15;

        const ENEMY_SPEED = 80;
        const ENEMY_SIZE = 20; 
        const ENEMY_DMG = 5;
        const KNOCKBACK_FORCE = 600;
        
        const POWERUP_DROP_CHANCE = 0.15;
        const POWERUP_SIZE = 15;
        const POWERUP_LIFETIME = 15.0; 
        const POWERUP_BLINK_TIME = 3.0;
        const POWERUP_DURATION = 10;
        
        // Axe Weapon Stats
        const AXE_EPIC_CHANCE = 0.0005; // 0.05% - Very Rare!
        const AXE_RARE_CHANCE = 0.002;  // 0.2%
        const AXE_NORMAL_CHANCE = 0.005; // 0.5%
        
        const REVIVE_TOKEN_CHANCE = 0.02; // 2% chance when Talamasca is dead

        // Weapon Tiers: Sword=0, NormalAxe=1, RareAxe=2, EpicAxe=3
        const WEAPON_STATS = {
            0: { range: SWORD_RANGE, dmgMult: 1.0, color: '#e5e7eb', name: 'Sword' },
            1: { range: SWORD_RANGE * 1.1, dmgMult: 1.0, color: '#9ca3af', name: 'Normal Axe' },
            2: { range: SWORD_RANGE * 1.1, dmgMult: 1.2, color: '#60a5fa', name: 'Rare Axe' },
            3: { range: SWORD_RANGE * 1.1, dmgMult: 1.4, color: '#a855f7', name: 'Epic Axe' }
        };
        
        const WARLORD_SIZE = 40;
        const WARLORD_HP_MULTIPLIER = 10;
        const WARLORD_DMG = 15;
        const FIREBALL_SPEED = 300;
        const FIREBALL_SIZE = 10;
        const WARLORD_ATTACK_RATE = 4;

        // --- Game State ---
        let lastTime = 0;
        let isGameOver = false;
        let isGameActive = false;
        let wave = 1;
        let keys = {};
        let mousePressed = false;
        let powerups = [];
        let fireballs = [];
        let warlordAttackTimer = WARLORD_ATTACK_RATE;

        // --- Entities ---
        
        const player = {
            x: 400, y: 300, radius: PLAYER_SIZE,
            hp: 100, maxHp: 100, angle: 0, speedMultiplier: 1.0,
            isAttacking: false, attackTimer: 0, attackCooldownTimer: 0, isBlocking: false,
            damageBoostTimer: 0, originalDamage: 20, currentDamage: 20,
            kills: 0,
            
            // Weapon state
            weaponType: 'sword', // visual type
            weaponTier: 0,       // 0:Sword, 1:Normal, 2:Rare, 3:Epic
            weaponRange: SWORD_RANGE,
            
            grapple: {
                active: false, state: 'idle', x: 0, y: 0, startX: 0, startY: 0,
                vx: 0, vy: 0, target: null, ropeLength: 0, idealAngle: 0
            },
            color: '#ffdbac'
        };

        const talamasca = {
            x: 350, y: 300, radius: PLAYER_SIZE, angle: 0, speedMultiplier: 1.0,
            hp: 50, maxHp: 50, dead: false,
            isAttacking: false, attackTimer: 0, attackCooldownTimer: 0,
            kills: 0,
            color: '#ffdbac', hairColor: '#ffd700',
            
            // Undead Scaling
            reviveCount: 0,
            isSkeletal: false
        };

        let enemies = [];
        let particles = [];
        let environment = [];

        function generateEnvironment() {
            environment = [];
            const count = 15;
            for(let i=0; i<count; i++) {
                const typeRand = Math.random();
                let type = 'tree';
                let radius = 30;
                if (typeRand < 0.33) { type = 'rock'; radius = 25; }
                else if (typeRand < 0.66) { type = 'bush'; radius = 25; }
                else { type = 'tree'; radius = 20; }

                let x, y, dist;
                do {
                    x = Math.random() * (canvas.width - 100) + 50;
                    y = Math.random() * (canvas.height - 100) + 50;
                    dist = Math.sqrt((x - 400)**2 + (y - 300)**2);
                } while (dist < 150);

                environment.push({ type: type, x: x, y: y, radius: radius, visualRadius: type === 'tree' ? 60 : radius });
            }
        }

        // --- Input Handling ---
        window.addEventListener('keydown', e => {
            keys[e.code] = true;
            // Prevent default for movement keys and Alt (Block)
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Space', 'KeyW', 'KeyA', 'KeyS', 'KeyD', 'AltLeft', 'AltRight'].includes(e.code)) {
                e.preventDefault();
            }
        });
        window.addEventListener('keyup', e => keys[e.code] = false);
        
        canvas.addEventListener('mousedown', e => {
            if (e.button === 0) mousePressed = true;
        });
        window.addEventListener('mouseup', e => {
            if (e.button === 0) mousePressed = false;
        });

        restartBtn.addEventListener('click', resetGame);

        // --- Helper Functions ---
        function getDistance(e1, e2) {
            return Math.sqrt((e1.x - e2.x)**2 + (e1.y - e2.y)**2);
        }

        function handleLootDrop(x, y) {
            const rand = Math.random();
            
            // 1. Check Revive Token (Angel Wings) - Only if Talamasca is dead
            if (talamasca.dead && Math.random() < REVIVE_TOKEN_CHANCE) {
                powerups.push({ x, y, type: 'revive', radius: POWERUP_SIZE, life: 30 });
                return; // Priority drop
            }
            
            // 2. Waterfall check: Axe
            if (rand < AXE_EPIC_CHANCE) {
                powerups.push({ x, y, type: 'axe', tier: 3, radius: POWERUP_SIZE, life: 30 }); 
                return;
            }
            if (rand < AXE_RARE_CHANCE) {
                powerups.push({ x, y, type: 'axe', tier: 2, radius: POWERUP_SIZE, life: 30 });
                return;
            }
            if (rand < AXE_NORMAL_CHANCE) {
                powerups.push({ x, y, type: 'axe', tier: 1, radius: POWERUP_SIZE, life: 30 });
                return;
            }

            // 3. Normal Powerups (Health/Damage Boost)
            if (Math.random() < POWERUP_DROP_CHANCE) {
                const typeRand = Math.random();
                let type = (typeRand < 0.5) ? 'health' : 'damage';
                powerups.push({ x, y, type, radius: POWERUP_SIZE, life: POWERUP_LIFETIME });
            }
        }
        
        function updateKillUI() {
            playerKillCountEl.textContent = `Orcs Slain: ${player.kills}`;
            talamascaKillCountEl.textContent = `Orcs Slain: ${talamasca.kills}`;
        }
        
        function recalculateStats() {
            // Get stats based on current weapon tier
            const stats = WEAPON_STATS[player.weaponTier];
            let base = 20 * stats.dmgMult;
            
            // Multiplier from temporary boost
            if (player.damageBoostTimer > 0) {
                player.currentDamage = base * 2;
            } else {
                player.currentDamage = base;
            }
            
            player.weaponRange = stats.range;
            player.weaponType = (player.weaponTier > 0) ? 'axe' : 'sword';
        }

        // --- Spawning Logic ---
        function spawnWave() {
            waveLabel.textContent = `WAVE ${wave}`;
            const count = 2 + Math.floor(wave * 1.5);
            const getSpawnPos = () => {
                let ex, ey;
                if (Math.random() < 0.5) {
                    ex = Math.random() < 0.5 ? -50 : canvas.width + 50;
                    ey = Math.random() * canvas.height;
                } else {
                    ex = Math.random() * canvas.width;
                    ey = Math.random() < 0.5 ? -50 : canvas.height + 50;
                }
                return {x: ex, y: ey};
            };

            for(let i=0; i<count; i++) {
                const pos = getSpawnPos();
                enemies.push({
                    x: pos.x, y: pos.y, radius: ENEMY_SIZE,
                    hp: 30 + (wave * 5), maxHp: 30 + (wave * 5),
                    vx: 0, vy: 0, knockbackX: 0, knockbackY: 0,
                    color: '#ef4444', speedMultiplier: 1.0, baseSpeed: ENEMY_SPEED,
                    isBoss: false
                });
            }

            if (wave % 10 === 0) {
                const pos = getSpawnPos();
                enemies.push({
                    x: pos.x, y: pos.y, radius: WARLORD_SIZE,
                    hp: (30 + (wave * 5)) * WARLORD_HP_MULTIPLIER, 
                    maxHp: (30 + (wave * 5)) * WARLORD_HP_MULTIPLIER,
                    vx: 0, vy: 0, knockbackX: 0, knockbackY: 0,
                    color: '#8b0000', baseSpeed: ENEMY_SPEED * 0.4, isBoss: true
                });
            } else if (wave % 5 === 0) {
                const pos = getSpawnPos();
                enemies.push({
                    x: pos.x, y: pos.y, radius: ENEMY_SIZE * 2, 
                    hp: (30 + (wave * 5)) * 5, maxHp: (30 + (wave * 5)) * 5,
                    vx: 0, vy: 0, knockbackX: 0, knockbackY: 0,
                    color: '#7f1d1d', speedMultiplier: 1.0, baseSpeed: ENEMY_SPEED * 0.5, isBoss: false
                });
            }
        }

        function createParticle(x, y, color) {
            particles.push({ x, y, vx: (Math.random() - 0.5) * 200, vy: (Math.random() - 0.5) * 200, life: 0.5, color });
        }

        function resolveEnvironmentCollisions(entity) {
            entity.speedMultiplier = 1.0;
            environment.forEach(obj => {
                const dist = getDistance(entity, obj);
                if (obj.type === 'bush') {
                    if (dist < obj.radius + entity.radius) entity.speedMultiplier = 0.5;
                } else {
                    if (dist < obj.radius + entity.radius) {
                        const overlap = (obj.radius + entity.radius) - dist;
                        const angle = Math.atan2(entity.y - obj.y, entity.x - obj.x);
                        entity.x += Math.cos(angle) * overlap;
                        entity.y += Math.sin(angle) * overlap;
                    }
                }
            });
        }
        
        function shootFireball(boss) {
            let target = player;
            if (!talamasca.dead) {
                if (getDistance(boss, talamasca) < getDistance(boss, player)) target = talamasca;
            }
            const angle = Math.atan2(target.y - boss.y, target.x - boss.x);
            fireballs.push({ x: boss.x, y: boss.y, radius: FIREBALL_SIZE, vx: Math.cos(angle) * FIREBALL_SPEED, vy: Math.sin(angle) * FIREBALL_SPEED, damage: WARLORD_DMG });
        }

        function updateTalamasca(dt) {
            if (talamasca.dead) return;
            
            // Calculate Stats based on Revive Count
            const currentRange = TAL_SWORD_RANGE * (1 + 0.25 * talamasca.reviveCount);
            const currentDamage = TAL_DAMAGE * (1 + 0.5 * talamasca.reviveCount);

            let target = null;
            let minDist = Infinity;
            enemies.forEach(e => {
                const d = getDistance(talamasca, e);
                if (d < minDist) { minDist = d; target = e; }
            });

            let moveX = 0; let moveY = 0;
            if (target) {
                const angle = Math.atan2(target.y - talamasca.y, target.x - talamasca.x);
                talamasca.angle = angle;
                if (minDist > currentRange - 10) { moveX = Math.cos(angle); moveY = Math.sin(angle); }
            } else {
                const distToPlayer = getDistance(talamasca, player);
                if (distToPlayer > 80) {
                    const angle = Math.atan2(player.y - talamasca.y, player.x - talamasca.x);
                    talamasca.angle = angle;
                    moveX = Math.cos(angle); moveY = Math.sin(angle);
                }
            }

            resolveEnvironmentCollisions(talamasca);
            talamasca.x += moveX * TAL_SPEED * talamasca.speedMultiplier * dt;
            talamasca.y += moveY * TAL_SPEED * talamasca.speedMultiplier * dt;
            talamasca.x = Math.max(talamasca.radius, Math.min(canvas.width - talamasca.radius, talamasca.x));
            talamasca.y = Math.max(talamasca.radius, Math.min(canvas.height - talamasca.radius, talamasca.y));

            if (talamasca.attackCooldownTimer > 0) talamasca.attackCooldownTimer -= dt;
            if (target && minDist < currentRange + target.radius + 10 && talamasca.attackCooldownTimer <= 0) {
                talamasca.isAttacking = true;
                talamasca.attackTimer = TAL_ATTACK_DUR;
                talamasca.attackCooldownTimer = TAL_ATTACK_CD;
                if (minDist < currentRange + target.radius) {
                     target.hp -= currentDamage;
                     createParticle(target.x, target.y, '#fff');
                     const angle = Math.atan2(target.y - talamasca.y, target.x - talamasca.x);
                     target.knockbackX += Math.cos(angle) * 100;
                     target.knockbackY += Math.sin(angle) * 100;
                     if (target.hp <= 0) {
                        talamasca.kills++; // Increment Kill Count
                        updateKillUI();
                        handleLootDrop(target.x, target.y);
                        enemies = enemies.filter(e => e !== target);
                        createParticle(target.x, target.y, '#ef4444');
                     }
                }
            }
            if (talamasca.isAttacking) {
                talamasca.attackTimer -= dt;
                if (talamasca.attackTimer <= 0) talamasca.isAttacking = false;
            }
        }

        function update(dt) {
            if (isGameOver || !isGameActive) return;

            updateTalamasca(dt);

            if (player.damageBoostTimer > 0) {
                player.damageBoostTimer -= dt;
                if (player.damageBoostTimer <= 0) { player.damageBoostTimer = 0; }
            }
            // Recalculate stats every frame to ensure correct damage (axe/boost combo)
            recalculateStats();


            resolveEnvironmentCollisions(player);

            let dx = 0; let dy = 0;
            // Updated Movement Logic to include WASD
            if (keys['ArrowUp'] || keys['KeyW']) dy -= 1;
            if (keys['ArrowDown'] || keys['KeyS']) dy += 1;
            if (keys['ArrowLeft'] || keys['KeyA']) dx -= 1;
            if (keys['ArrowRight'] || keys['KeyD']) dx += 1;
            
            if (dx !== 0 || dy !== 0) {
                player.angle = Math.atan2(dy, dx);
                const len = Math.sqrt(dx*dx + dy*dy);
                dx /= len; dy /= len;
                let finalSpeed = PLAYER_SPEED * player.speedMultiplier;
                if (player.isBlocking) finalSpeed *= 0.4;
                player.x += dx * finalSpeed * dt;
                player.y += dy * finalSpeed * dt;
            }
            
            player.x = Math.max(player.radius, Math.min(canvas.width - player.radius, player.x));
            player.y = Math.max(player.radius, Math.min(canvas.height - player.radius, player.y));

            // Updated Block Logic to use 'Alt'
            player.isBlocking = keys['AltLeft'] || keys['AltRight'];
            
            if (player.attackCooldownTimer > 0) player.attackCooldownTimer -= dt;
            
            // Updated Attack Logic to include Mouse Press
            if ((keys['Space'] || mousePressed) && player.attackCooldownTimer <= 0 && !player.isBlocking && !player.isAttacking) {
                player.isAttacking = true;
                player.attackTimer = ATTACK_DURATION;
                player.attackCooldownTimer = ATTACK_COOLDOWN;
                checkAttackHits();
            }

            if (player.isAttacking) {
                player.attackTimer -= dt;
                if (player.attackTimer <= 0) player.isAttacking = false;
            }
            
            for (let i = powerups.length - 1; i >= 0; i--) {
                const p = powerups[i];
                p.life -= dt;
                if (p.life <= 0) {
                    powerups.splice(i, 1);
                    continue;
                }

                if (getDistance(player, p) < player.radius + p.radius) {
                    if (p.type === 'health') {
                        player.hp = Math.min(player.maxHp, player.hp + PLAYER_HEAL_AMOUNT);
                        playerHpBar.style.width = `${(player.hp / player.maxHp) * 100}%`;
                    } else if (p.type === 'damage') { 
                        player.damageBoostTimer = POWERUP_DURATION; 
                    } else if (p.type === 'axe') {
                        // Check Tier Upgrade (Waterfall logic)
                        if (p.tier > player.weaponTier) {
                            player.weaponTier = p.tier;
                            recalculateStats();
                            createParticle(player.x, player.y, WEAPON_STATS[p.tier].color);
                        }
                    } else if (p.type === 'revive') {
                        // Revive Talamasca
                        talamasca.dead = false;
                        talamasca.hp = talamasca.maxHp;
                        talamasca.reviveCount++;
                        talamasca.isSkeletal = true;
                        talamasca.color = '#e5e5e5'; // Bone color
                        talamascaHpBar.style.backgroundColor = '#fbbf24'; // Restore bar color
                        talamascaHpBar.style.width = '100%';
                        createParticle(player.x, player.y, '#ffffff'); // White effect
                    }
                    powerups.splice(i, 1);
                }
            }

            if (enemies.length === 0) { wave++; spawnWave(); }

            if (wave % 10 === 0) {
                 warlordAttackTimer -= dt;
                 if (warlordAttackTimer <= 0) {
                    enemies.filter(e => e.isBoss).forEach(boss => shootFireball(boss));
                    warlordAttackTimer = WARLORD_ATTACK_RATE;
                 }
            }
            
            for (let i = fireballs.length - 1; i >= 0; i--) {
                const f = fireballs[i];
                f.x += f.vx * dt; f.y += f.vy * dt;
                let hitHero = null;
                if (getDistance(f, player) < f.radius + player.radius) hitHero = player;
                else if (!talamasca.dead && getDistance(f, talamasca) < f.radius + talamasca.radius) hitHero = talamasca;

                if (hitHero) {
                    if (hitHero === player && player.isBlocking) { takeDamage(f.damage * 0.5); createParticle(f.x, f.y, '#fbbf24'); }
                    else if (hitHero === player) takeDamage(f.damage);
                    else if (hitHero === talamasca) takeTalamascaDamage(f.damage);
                    fireballs.splice(i, 1);
                }
                if (f.x < -100 || f.x > canvas.width + 100 || f.y < -100 || f.y > canvas.height + 100) fireballs.splice(i, 1);
            }

            enemies.forEach((enemy, index) => {
                resolveEnvironmentCollisions(enemy);
                enemy.x += enemy.knockbackX * dt;
                enemy.y += enemy.knockbackY * dt;
                enemy.knockbackX *= 0.9;
                enemy.knockbackY *= 0.9;

                let targetHero = player;
                if (!talamasca.dead) {
                    if (getDistance(enemy, talamasca) < getDistance(enemy, player)) targetHero = talamasca;
                }

                if (Math.abs(enemy.knockbackX) < 10 && Math.abs(enemy.knockbackY) < 10) {
                    const angleToTarget = Math.atan2(targetHero.y - enemy.y, targetHero.x - enemy.x);
                    const currentSpeed = (enemy.baseSpeed || ENEMY_SPEED) * enemy.speedMultiplier;
                    enemy.x += Math.cos(angleToTarget) * currentSpeed * dt;
                    enemy.y += Math.sin(angleToTarget) * currentSpeed * dt;
                }

                enemy.x = Math.max(enemy.radius, Math.min(canvas.width - enemy.radius, enemy.x));
                enemy.y = Math.max(enemy.radius, Math.min(canvas.height - enemy.radius, enemy.y));

                const dist = getDistance(targetHero, enemy);
                if (dist < targetHero.radius + enemy.radius) {
                    const angleToTarget = Math.atan2(targetHero.y - enemy.y, targetHero.x - enemy.x);
                    if (targetHero === player) {
                        const angleToEnemy = Math.atan2(enemy.y - player.y, enemy.x - player.x);
                        let angleDiff = angleToEnemy - player.angle;
                        while (angleDiff > Math.PI) angleDiff -= Math.PI*2;
                        while (angleDiff < -Math.PI) angleDiff += Math.PI*2;
                        if (player.isBlocking && Math.abs(angleDiff) < Math.PI / 2) {
                            createParticle((player.x + enemy.x)/2, (player.y + enemy.y)/2, '#fbbf24');
                            enemy.knockbackX = -Math.cos(angleToTarget) * 200;
                            enemy.knockbackY = -Math.sin(angleToTarget) * 200;
                        } else {
                            takeDamage(ENEMY_DMG);
                            player.x += Math.cos(angleToTarget) * 10;
                            player.y += Math.sin(angleToTarget) * 10;
                        }
                    } else {
                        takeTalamascaDamage(ENEMY_DMG);
                        talamasca.x += Math.cos(angleToTarget) * 10;
                        talamasca.y += Math.sin(angleToTarget) * 10;
                    }
                    const overlap = (targetHero.radius + enemy.radius) - dist;
                    enemy.x -= Math.cos(angleToTarget) * overlap;
                    enemy.y -= Math.sin(angleToTarget) * overlap;
                }
            });

            particles.forEach((p, i) => { p.x += p.vx * dt; p.y += p.vy * dt; p.life -= dt; if(p.life <= 0) particles.splice(i, 1); });
        }

        function checkAttackHits() {
            enemies.forEach((enemy, index) => {
                const dist = getDistance(player, enemy);
                // Use Dynamic Weapon Range
                if (dist < player.weaponRange + enemy.radius) {
                    const angleToEnemy = Math.atan2(enemy.y - player.y, enemy.x - player.x);
                    let angleDiff = angleToEnemy - player.angle;
                    while (angleDiff > Math.PI) angleDiff -= Math.PI*2;
                    while (angleDiff < -Math.PI) angleDiff += Math.PI*2;
                    if (Math.abs(angleDiff) < SWORD_ARC / 2) {
                        enemy.hp -= player.currentDamage;
                        createParticle(enemy.x, enemy.y, '#fff'); 
                        enemy.knockbackX = Math.cos(angleToEnemy) * KNOCKBACK_FORCE;
                        enemy.knockbackY = Math.sin(angleToEnemy) * KNOCKBACK_FORCE;
                        if (enemy.hp <= 0) { 
                            player.kills++; // Increment Kill Count
                            updateKillUI();
                            handleLootDrop(enemy.x, enemy.y); 
                            enemies.splice(index, 1); 
                            createParticle(enemy.x, enemy.y, '#ef4444'); 
                        }
                    }
                }
            });
        }

        function takeDamage(amount) {
            player.hp -= amount;
            playerHpBar.style.width = `${(player.hp / player.maxHp) * 100}%`;
            createParticle(player.x, player.y, '#dc2626');
            if (player.hp <= 0) gameOver();
        }

        function takeTalamascaDamage(amount) {
            talamasca.hp -= amount;
            if (talamasca.hp < 0) talamasca.hp = 0;
            talamascaHpBar.style.width = `${(talamasca.hp / talamasca.maxHp) * 100}%`;
            createParticle(talamasca.x, talamasca.y, '#dc2626');
            if (talamasca.hp <= 0) { talamasca.dead = true; talamascaHpBar.style.backgroundColor = '#555'; }
        }

        function gameOver() {
            isGameOver = true; isGameActive = false;
            msgTitle.textContent = "YOU DIED";
            msgScore.innerHTML = `You survived ${wave - 1} waves.<br><br>
                                  Northstar Kills: ${player.kills}<br>
                                  Talamasca Kills: ${talamasca.kills}`;
            restartBtn.textContent = "Try Again";
            messageBox.style.display = 'flex';
        }

        function resetGame() {
            player.hp = player.maxHp; player.x = canvas.width/2; player.y = canvas.height/2;
            playerHpBar.style.width = '100%';
            player.damageBoostTimer = 0; player.currentDamage = player.originalDamage;
            player.kills = 0; // Reset Kills
            // Reset Weapon
            player.weaponType = 'sword';
            player.weaponRange = SWORD_RANGE;
            player.weaponTier = 0;

            talamasca.kills = 0; // Reset Kills
            talamasca.reviveCount = 0;
            talamasca.isSkeletal = false;
            talamasca.color = '#ffdbac';
            updateKillUI(); // Update UI

            enemies = []; particles = []; powerups = []; fireballs = []; wave = 1; isGameOver = false;
            warlordAttackTimer = WARLORD_ATTACK_RATE;
            talamasca.hp = talamasca.maxHp; talamasca.dead = false;
            talamasca.x = player.x - 50; talamasca.y = player.y;
            talamascaHpBar.style.width = '100%'; talamascaHpBar.style.backgroundColor = '#fbbf24';
            generateEnvironment(); spawnWave();
            isGameActive = true; messageBox.style.display = 'none';
            lastTime = performance.now();
        }

        // --- Drawing Logic ---

        function draw() {
            ctx.fillStyle = '#2d3e26'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = '#3a4f32'; ctx.lineWidth = 2; ctx.beginPath();
            for(let x=0; x<canvas.width; x+=50) { ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); }
            for(let y=0; y<canvas.height; y+=50) { ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); }
            ctx.stroke();

            environment.forEach(obj => {
                if(obj.type === 'bush') {
                    ctx.fillStyle = '#1e5c24'; ctx.beginPath(); ctx.arc(obj.x, obj.y, obj.radius, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = '#a8201a'; ctx.beginPath(); ctx.arc(obj.x-5, obj.y-5, 3, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(obj.x+8, obj.y+2, 3, 0, Math.PI*2); ctx.fill();
                }
            });

            powerups.forEach(p => {
                ctx.save(); ctx.translate(p.x, p.y); 
                
                // Blinking Effect
                if (p.life < POWERUP_BLINK_TIME) {
                    if (Math.floor(p.life * 5) % 2 === 0) ctx.globalAlpha = 0.3;
                }

                ctx.beginPath(); ctx.arc(0, 0, p.radius, 0, Math.PI * 2);
                if (p.type === 'health') {
                    ctx.fillStyle = '#4ade80'; ctx.fill(); ctx.fillStyle = '#16a34a'; ctx.fillRect(-3, -8, 6, 16); ctx.fillRect(-8, -3, 16, 6);
                } else if (p.type === 'damage') {
                    ctx.fillStyle = '#a855f7'; ctx.fill(); ctx.fillStyle = '#ffffff'; ctx.beginPath();
                    ctx.moveTo(0, -7); ctx.lineTo(7, 3); ctx.lineTo(0, 3); ctx.lineTo(-7, 7); ctx.lineTo(0, -3); ctx.lineTo(-7, -3); ctx.fill();
                } else if (p.type === 'axe') {
                    // Color based on Tier
                    ctx.fillStyle = WEAPON_STATS[p.tier].color; 
                    ctx.fill(); 
                    // Draw Axe Icon
                    ctx.fillStyle = '#222';
                    ctx.beginPath();
                    ctx.moveTo(-5, 0); ctx.lineTo(5, 5); ctx.lineTo(5, -5); ctx.fill();
                    ctx.fillRect(0, -8, 3, 16);
                } else if (p.type === 'revive') {
                    ctx.fillStyle = '#ffffff'; ctx.fill();
                    // Draw Wings
                    ctx.fillStyle = '#fbbf24'; // Gold
                    ctx.beginPath(); ctx.ellipse(-6, -2, 8, 4, -0.5, 0, Math.PI*2); ctx.fill(); // Left wing
                    ctx.beginPath(); ctx.ellipse(6, -2, 8, 4, 0.5, 0, Math.PI*2); ctx.fill(); // Right wing
                    ctx.beginPath(); ctx.arc(0, 5, 2, 0, Math.PI*2); ctx.fill(); // Halo/Center
                }
                ctx.restore();
            });

            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            const entities = [player, ...enemies]; if (!talamasca.dead) entities.push(talamasca);
            entities.forEach(obj => {
                ctx.beginPath(); const r = obj.radius || 20; ctx.ellipse(obj.x, obj.y + 5, r, r*0.6, 0, 0, Math.PI*2); ctx.fill();
            });

            environment.forEach(obj => {
                if (obj.type === 'rock') { ctx.fillStyle = '#57534e'; ctx.beginPath(); ctx.arc(obj.x, obj.y, obj.radius, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#78716c'; ctx.beginPath(); ctx.arc(obj.x - 5, obj.y - 5, obj.radius/2, 0, Math.PI*2); ctx.fill(); }
                else if (obj.type === 'tree') { ctx.fillStyle = '#3f2e21'; ctx.beginPath(); ctx.arc(obj.x, obj.y, obj.radius, 0, Math.PI*2); ctx.fill(); }
            });
            
            fireballs.forEach(f => {
                ctx.fillStyle = '#f97316'; ctx.beginPath(); ctx.arc(f.x, f.y, f.radius, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#ef4444'; ctx.beginPath(); ctx.arc(f.x, f.y, f.radius * 0.5, 0, Math.PI * 2); ctx.fill();
            });

            enemies.forEach(e => {
                let target = player; if (!talamasca.dead) { if (getDistance(e, talamasca) < getDistance(e, player)) target = talamasca; }
                const angle = Math.atan2(target.y - e.y, target.x - e.x);
                ctx.save(); ctx.translate(e.x, e.y); ctx.rotate(angle);
                const scale = e.radius / ENEMY_SIZE; ctx.scale(scale, scale);
                ctx.fillStyle = '#fef3c7'; ctx.beginPath(); ctx.moveTo(5, -10); ctx.lineTo(18, -20); ctx.lineTo(12, -5); ctx.fill();
                ctx.beginPath(); ctx.moveTo(5, 10); ctx.lineTo(18, 20); ctx.lineTo(12, 5); ctx.fill();
                ctx.fillStyle = e.color; ctx.beginPath(); ctx.arc(0, 0, ENEMY_SIZE, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = '#fbbf24'; ctx.beginPath(); ctx.arc(10, -6, 3, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(10, 6, 3, 0, Math.PI*2); ctx.fill();
                ctx.restore();
                const barYOffset = e.radius + 15; ctx.fillStyle = 'black'; ctx.fillRect(e.x - 15, e.y - barYOffset, 30, 5); ctx.fillStyle = '#dc2626'; ctx.fillRect(e.x - 15, e.y - barYOffset, 30 * (e.hp/e.maxHp), 5);
            });

            if (!talamasca.dead) {
                ctx.save(); ctx.translate(talamasca.x, talamasca.y); ctx.rotate(talamasca.angle);
                
                // Weapon Logic (Sword vs Scythe)
                const weaponRange = TAL_SWORD_RANGE * (1 + 0.25 * talamasca.reviveCount);
                if (talamasca.isAttacking) { 
                    ctx.save(); 
                    const progress = 1 - (talamasca.attackTimer / TAL_ATTACK_DUR); 
                    ctx.translate(progress * 20, 0); 
                    
                    if (talamasca.isSkeletal) {
                         // Draw Scythe
                         ctx.fillStyle = '#52525b'; // Dark handle
                         ctx.fillRect(10, -3, weaponRange, 4); 
                         ctx.fillStyle = '#e2e8f0'; // Blade
                         ctx.beginPath();
                         ctx.arc(10 + weaponRange, -3, 20, Math.PI/2, Math.PI * 1.5);
                         ctx.fill();
                    } else {
                         // Draw Sword/Dagger
                         ctx.fillStyle = '#e2e8f0'; 
                         ctx.fillRect(10, -3, weaponRange, 6); 
                    }
                    ctx.restore(); 
                }
                else { 
                    ctx.fillStyle = '#94a3b8'; 
                    ctx.fillRect(10, 10, 40, 4); 
                }

                if (talamasca.isSkeletal) {
                     // Skeletal Appearance
                     ctx.fillStyle = talamasca.color; // Bone
                     ctx.beginPath(); ctx.arc(0, 0, talamasca.radius, 0, Math.PI*2); ctx.fill();
                     // Dark empty eyes
                     ctx.fillStyle = '#111'; 
                     ctx.beginPath(); ctx.arc(10, -5, 4, 0, Math.PI*2); ctx.fill();
                     ctx.beginPath(); ctx.arc(10, 5, 4, 0, Math.PI*2); ctx.fill();
                } else {
                     // Human Appearance
                     ctx.fillStyle = talamasca.hairColor; ctx.beginPath(); ctx.ellipse(-15, 0, talamasca.radius * 1.5, talamasca.radius * 0.8, 0, 0, Math.PI*2); ctx.fill();
                     ctx.fillStyle = talamasca.color; ctx.beginPath(); ctx.arc(0, 0, talamasca.radius, 0, Math.PI*2); ctx.fill();
                     ctx.fillStyle = talamasca.hairColor; ctx.beginPath(); ctx.arc(2, 0, talamasca.radius + 1, -Math.PI/2 - 0.5, Math.PI/2 + 0.5, true); ctx.fill();
                     ctx.fillStyle = '#3b82f6'; ctx.fillRect(10, -3, 5, 5); ctx.fillRect(10, 3, 5, 5); 
                }
                ctx.restore();
            }

            ctx.save(); ctx.translate(player.x, player.y); ctx.rotate(player.angle);
            if (player.damageBoostTimer > 0) { ctx.fillStyle = `rgba(168, 85, 247, ${0.4 + 0.2 * Math.sin(performance.now() / 100)})`; ctx.beginPath(); ctx.arc(0, 0, player.radius + 15, 0, Math.PI * 2); ctx.fill(); const remaining = player.damageBoostTimer.toFixed(1); ctx.fillStyle = '#fff'; ctx.font = '14px Courier New'; ctx.fillText(remaining, -10, -player.radius - 20); }
            if (player.isAttacking) { 
                ctx.save(); const progress = 1 - (player.attackTimer / ATTACK_DURATION); const swingAngle = -Math.PI/3 + (progress * Math.PI * 2/3); ctx.rotate(swingAngle); 
                
                // Color based on held weapon tier if boost is not active
                if (player.damageBoostTimer > 0) {
                     ctx.fillStyle = '#ffcc00';
                } else {
                     ctx.fillStyle = WEAPON_STATS[player.weaponTier].color;
                }

                if (player.weaponType === 'axe') {
                    // Draw Axe
                    ctx.fillRect(0, -3, player.weaponRange, 6); // Handle
                    ctx.beginPath();
                    ctx.moveTo(player.weaponRange - 10, -10);
                    ctx.lineTo(player.weaponRange + 5, -20);
                    ctx.lineTo(player.weaponRange + 5, 20);
                    ctx.lineTo(player.weaponRange - 10, 10);
                    ctx.fill();
                } else {
                    // Draw Sword
                    ctx.fillRect(0, -5, SWORD_RANGE, 10);
                }
                ctx.restore(); 
            }
            else { 
                // Idle weapon color
                ctx.fillStyle = WEAPON_STATS[player.weaponTier].color;
                if (player.weaponTier === 0) ctx.fillStyle = '#94a3b8'; // Default sword color if tier 0

                if (player.weaponType === 'axe') {
                    ctx.fillRect(0, 15, 30, 4); // Axe Idle
                } else {
                    ctx.fillRect(0, 15, 30, 5); // Sword Idle
                }
            }
            if (player.isBlocking) { ctx.beginPath(); ctx.arc(0, 0, player.radius + 10, -Math.PI/3, Math.PI/3); ctx.strokeStyle = '#fbbf24'; ctx.lineWidth = 5; ctx.stroke(); ctx.fillStyle = 'rgba(251, 191, 36, 0.3)'; ctx.fill(); }
            ctx.fillStyle = '#a0522d'; ctx.beginPath(); ctx.arc(-8, 0, player.radius * 0.9, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(-2, 0, player.radius, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = player.color; ctx.beginPath(); ctx.arc(3, 0, player.radius - 2, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = '#333'; ctx.fillRect(12, -8, 5, 5); ctx.fillRect(12, 3, 5, 5); ctx.restore();

            environment.forEach(obj => {
                if (obj.type === 'tree') { ctx.fillStyle = 'rgba(34, 197, 94, 0.9)'; ctx.beginPath(); ctx.arc(obj.x, obj.y, obj.visualRadius, 0, Math.PI*2); ctx.fill(); ctx.fillStyle = '#4ade80'; ctx.beginPath(); ctx.arc(obj.x - 10, obj.y - 10, obj.visualRadius/2, 0, Math.PI*2); ctx.fill(); }
            });

            particles.forEach(p => { ctx.fillStyle = p.color; ctx.globalAlpha = p.life; ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill(); ctx.globalAlpha = 1.0; });
        }

        function gameLoop(timestamp) {
            const dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;
            update(dt);
            draw();
            requestAnimationFrame(gameLoop);
        }

        window.onload = () => {
            player.x = canvas.width/2; player.y = canvas.height/2;
            talamasca.x = player.x - 50; talamasca.y = player.y;
            generateEnvironment(); 
            playerHpBar.style.width = '100%'; talamascaHpBar.style.width = '100%'; waveLabel.textContent = 'WAVE 1';
            msgTitle.textContent = "Northstar's Noble Adventure";
            msgScore.textContent = "Press START to face the Orc Hordes.";
            restartBtn.textContent = "START GAME"; 
            messageBox.style.display = 'flex'; isGameActive = false;
            lastTime = performance.now();
            requestAnimationFrame(gameLoop);
        };
    </script>
</body>
</html>